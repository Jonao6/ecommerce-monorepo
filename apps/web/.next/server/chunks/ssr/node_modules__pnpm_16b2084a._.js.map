{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient%404.0.5_graphq_ce049ebab6b7b32bde04cae06d734544/node_modules/%40apollo/src/react/internal/index.ts"],"sourcesContent":["import type { InternalTypes as ReactInternalTypes } from \"@apollo/client/react\";\nexport { getSuspenseCache } from \"./cache/getSuspenseCache.js\";\nexport type { CacheKey, FragmentKey, QueryKey } from \"./cache/types.js\";\nexport type { PreloadedQueryRef, QueryRef } from \"./cache/QueryReference.js\";\nexport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  InternalQueryReference,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"./cache/QueryReference.js\";\nexport type { SuspenseCacheOptions } from \"./cache/SuspenseCache.js\";\nexport type HookWrappers = ReactInternalTypes.HookWrappers;\nexport const wrapperSymbol = Symbol.for(\"apollo.hook.wrappers\");\nexport type { FetchMoreFunction, RefetchFunction } from \"./types.js\";\n"],"names":[],"mappings":";;;;;AAcO,MAAM,aAAa,GAAG,MAAM,CAAC,GAAG,CAAC,sBAAsB,CAAC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"file":"wrapHook.js","sources":["file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient%404.0.5_graphq_ce049ebab6b7b32bde04cae06d734544/node_modules/%40apollo/src/react/hooks/internal/wrapHook.ts"],"sourcesContent":["import * as React from \"react\";\n\nimport type { ApolloClient, InternalTypes } from \"@apollo/client\";\nimport type { ObservableQuery } from \"@apollo/client\";\nimport type { createQueryPreloader } from \"@apollo/client/react\";\nimport type {\n  useBackgroundQuery,\n  useFragment,\n  useQuery,\n  useQueryRefHandlers,\n  useReadQuery,\n  useSuspenseFragment,\n  useSuspenseQuery,\n} from \"@apollo/client/react\";\nimport { wrapperSymbol } from \"@apollo/client/react/internal\";\n\n// direct import to avoid circular dependency\nimport { getApolloContext } from \"../../context/ApolloContext.js\";\n\ntype FunctionSignature<T> =\n  T extends (...args: infer A) => infer R ? (...args: A) => R : never;\n\ninterface WrappableHooks {\n  createQueryPreloader: FunctionSignature<typeof createQueryPreloader>;\n  useQuery: FunctionSignature<typeof useQuery>;\n  useSuspenseQuery: FunctionSignature<typeof useSuspenseQuery>;\n  useSuspenseFragment: FunctionSignature<typeof useSuspenseFragment>;\n  useBackgroundQuery: FunctionSignature<typeof useBackgroundQuery>;\n  useReadQuery: FunctionSignature<typeof useReadQuery>;\n  useFragment: FunctionSignature<typeof useFragment>;\n  useQueryRefHandlers: FunctionSignature<typeof useQueryRefHandlers>;\n}\n\n/**\n * @internal\n * Can be used to correctly type the [Symbol.for(\"apollo.hook.wrappers\")] property of\n * `QueryManager`, to override/wrap hook functionality.\n */\nexport type HookWrappers = {\n  [K in keyof WrappableHooks]?: (\n    originalHook: WrappableHooks[K]\n  ) => WrappableHooks[K];\n};\n\ninterface QueryManagerWithWrappers extends InternalTypes.QueryManager {\n  [wrapperSymbol]?: HookWrappers;\n}\n\n/**\n * @internal\n *\n * Makes an Apollo Client hook \"wrappable\".\n * That means that the Apollo Client instance can expose a \"wrapper\" that will be\n * used to wrap the original hook implementation with additional logic.\n * @example\n *\n * ```tsx\n * // this is already done in `@apollo/client` for all wrappable hooks (see `WrappableHooks`)\n * // following this pattern\n * function useQuery() {\n *   return wrapHook('useQuery', _useQuery, options.client)(query, options);\n * }\n * function _useQuery(query, options) {\n *   // original implementation\n * }\n *\n * // this is what a library like `@apollo/client-react-streaming` would do\n * class ApolloClientWithStreaming extends ApolloClient {\n *   constructor(options) {\n *     super(options);\n *     this.queryManager[Symbol.for(\"apollo.hook.wrappers\")] = {\n *       useQuery: (original) => (query, options) => {\n *         console.log(\"useQuery was called with options\", options);\n *         return original(query, options);\n *       }\n *     }\n *   }\n * }\n *\n * // this will now log the options and then call the original `useQuery`\n * const client = new ApolloClientWithStreaming({ ... });\n * useQuery(query, { client });\n * ```\n */\nexport function wrapHook<Hook extends (...args: any[]) => any>(\n  hookName: keyof WrappableHooks,\n  useHook: Hook,\n  clientOrObsQuery: ObservableQuery<any> | ApolloClient\n): Hook {\n  // Priority-wise, the later entries in this array wrap\n  // previous entries and could prevent them (and in the end,\n  // even the original hook) from running\n  const wrapperSources = [\n    (\n      clientOrObsQuery as unknown as {\n        // both `ApolloClient` and `ObservableQuery` have a `queryManager` property\n        // but they're both `private`, so we have to cast around for a bit here.\n        queryManager: QueryManagerWithWrappers;\n      }\n    )[\"queryManager\"],\n    // if we are a hook (not `preloadQuery`), we are guaranteed to be inside of\n    // a React render and can use context\n    hookName.startsWith(\"use\") ?\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React.useContext(getApolloContext())\n    : undefined,\n  ];\n\n  let wrapped = useHook;\n  for (const source of wrapperSources) {\n    const wrapper = source?.[wrapperSymbol]?.[hookName];\n    if (wrapper) {\n      wrapped = wrapper(wrapped) as Hook;\n    }\n  }\n\n  return wrapped;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"file":"constants.js","sourceRoot":"","sources":["file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient%404.0.5_graphq_ce049ebab6b7b32bde04cae06d734544/node_modules/%40apollo/src/react/hooks/constants.ts"],"sourcesContent":["export const skipToken = Symbol.for(\"apollo.skipToken\");\nexport type SkipToken = typeof skipToken;\n"],"names":[],"mappings":";;;AAAO,MAAM,SAAS,GAAG,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 65, "column": 0}, "map": {"version":3,"file":"__use.js","sourceRoot":"","sources":["file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient%404.0.5_graphq_ce049ebab6b7b32bde04cae06d734544/node_modules/%40apollo/src/react/hooks/internal/__use.ts"],"sourcesContent":["import * as React from \"react\";\n\nimport { decoratePromise } from \"@apollo/client/utilities/internal\";\n\ntype Use = <T>(promise: Promise<T>) => T;\n// Prevent webpack from complaining about our feature detection of the\n// use property of the React namespace, which is expected not\n// to exist when using current stable versions, and that's fine.\nconst useKey = \"use\" as keyof typeof React;\nconst realHook = React[useKey] as Use | undefined;\n\n// This is named with two underscores to allow this hook to evade typical rules of\n// hooks (i.e. it can be used conditionally)\nexport const __use =\n  realHook ||\n  function __use<TValue>(promise: Promise<TValue>) {\n    const decoratedPromise = decoratePromise(promise);\n\n    switch (decoratedPromise.status) {\n      case \"pending\":\n        throw decoratedPromise;\n      case \"rejected\":\n        throw decoratedPromise.reason;\n      case \"fulfilled\":\n        return decoratedPromise.value;\n    }\n  };\n"],"names":[],"mappings":";;;AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAE/B,OAAO,EAAE,eAAe,EAAE,MAAM,mCAAmC,CAAC;;;AAGpE,sEAAsE;AACtE,6DAA6D;AAC7D,gEAAgE;AAChE,MAAM,MAAM,GAAG,KAA2B,CAAC;AAC3C,MAAM,QAAQ,GAAG,oTAAK,CAAC,MAAM,CAAoB,CAAC;AAI3C,MAAM,KAAK,GAChB,QAAQ,IACR,SAAS,KAAK,CAAS,OAAwB;IAC7C,MAAM,gBAAgB,6RAAG,kBAAA,AAAe,EAAC,OAAO,CAAC,CAAC;IAElD,OAAQ,gBAAgB,CAAC,MAAM,EAAE,CAAC;QAChC,KAAK,SAAS;YACZ,MAAM,gBAAgB,CAAC;QACzB,KAAK,UAAU;YACb,MAAM,gBAAgB,CAAC,MAAM,CAAC;QAChC,KAAK,WAAW;YACd,OAAO,gBAAgB,CAAC,KAAK,CAAC;IAClC,CAAC;AACH,CAAC,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 94, "column": 0}, "map": {"version":3,"file":"useDeepMemo.js","sourceRoot":"","sources":["file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient%404.0.5_graphq_ce049ebab6b7b32bde04cae06d734544/node_modules/%40apollo/src/react/hooks/internal/useDeepMemo.ts"],"sourcesContent":["import { equal } from \"@wry/equality\";\nimport type { DependencyList } from \"react\";\nimport * as React from \"react\";\n\nexport function useDeepMemo<TValue>(\n  memoFn: () => TValue,\n  deps: DependencyList\n) {\n  const ref = React.useRef<{ deps: DependencyList; value: TValue }>(void 0);\n  if (!ref.current || !equal(ref.current.deps, deps)) {\n    ref.current = { value: memoFn(), deps };\n  }\n  return ref.current.value;\n}\n"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,eAAe,CAAC;AAEtC,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;;;AAEzB,SAAU,WAAW,CACzB,MAAoB,EACpB,IAAoB;IAEpB,MAAM,GAAG,4TAAG,KAAK,CAAC,GAAA,AAAM,EAA0C,KAAK,CAAC,CAAC,CAAC;IAC1E,IAAI,CAAC,GAAG,CAAC,OAAO,IAAI,qNAAC,QAAA,AAAK,EAAC,GAAG,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,CAAC;QACnD,GAAG,CAAC,OAAO,GAAG;YAAE,KAAK,EAAE,MAAM,EAAE;YAAE,IAAI;QAAA,CAAE,CAAC;IAC1C,CAAC;IACD,OAAO,GAAG,CAAC,OAAO,CAAC,KAAK,CAAC;AAC3B,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 117, "column": 0}, "map": {"version":3,"file":"validateSuspenseHookOptions.js","sources":["file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient%404.0.5_graphq_ce049ebab6b7b32bde04cae06d734544/node_modules/%40apollo/src/react/hooks/internal/validateSuspenseHookOptions.ts"],"sourcesContent":["import type {\n  ApolloClient,\n  OperationVariables,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nexport function validateSuspenseHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n>(options: ApolloClient.WatchQueryOptions<TData, TVariables>) {\n  const { fetchPolicy, returnPartialData } = options;\n\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(\n  fetchPolicy: WatchQueryFetchPolicy = \"cache-first\"\n) {\n  const supportedFetchPolicies: WatchQueryFetchPolicy[] = [\n    \"cache-first\",\n    \"network-only\",\n    \"no-cache\",\n    \"cache-and-network\",\n  ];\n\n  invariant(\n    supportedFetchPolicies.includes(fetchPolicy),\n    `The fetch policy \\`%s\\` is not supported with suspense.`,\n    fetchPolicy\n  );\n}\n\nfunction validatePartialDataReturn(\n  fetchPolicy: WatchQueryFetchPolicy | undefined,\n  returnPartialData: boolean | undefined\n) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    invariant.warn(\n      \"Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy.\"\n    );\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 149, "column": 0}, "map": {"version":3,"file":"useSuspenseQuery.js","sourceRoot":"","sources":["file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient%404.0.5_graphq_ce049ebab6b7b32bde04cae06d734544/node_modules/%40apollo/src/react/hooks/useSuspenseQuery.ts"],"sourcesContent":["import * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  DefaultContext,\n  DocumentNode,\n  ErrorLike,\n  ErrorPolicy,\n  GetDataState,\n  MaybeMasked,\n  ObservableQuery,\n  OperationVariables,\n  RefetchWritePolicy,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport type { SubscribeToMoreFunction } from \"@apollo/client\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport type {\n  CacheKey,\n  FetchMoreFunction,\n  QueryKey,\n  RefetchFunction,\n} from \"@apollo/client/react/internal\";\nimport { getSuspenseCache } from \"@apollo/client/react/internal\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { SkipToken } from \"./constants.js\";\nimport { skipToken } from \"./constants.js\";\nimport { __use, useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { validateSuspenseHookOptions } from \"./internal/validateSuspenseHookOptions.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport declare namespace useSuspenseQuery {\n  export type FetchPolicy = Extract<\n    WatchQueryFetchPolicy,\n    \"cache-first\" | \"network-only\" | \"no-cache\" | \"cache-and-network\"\n  >;\n\n  export namespace Base {\n    export interface Options<\n      TVariables extends OperationVariables = OperationVariables,\n    > {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n      client?: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n      context?: DefaultContext;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n      errorPolicy?: ErrorPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n      returnPartialData?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy_suspense:member} */\n      refetchWritePolicy?: RefetchWritePolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n      fetchPolicy?: FetchPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#queryKey:member} */\n      queryKey?: string | number | any[];\n\n      /**\n       * {@inheritDoc @apollo/client!QueryOptionsDocumentation#skip_deprecated:member}\n       *\n       * @example Recommended usage of `skipToken`:\n       *\n       * ```ts\n       * import { skipToken, useSuspenseQuery } from \"@apollo/client\";\n       *\n       * const { data } = useSuspenseQuery(\n       *   query,\n       *   id ? { variables: { id } } : skipToken\n       * );\n       * ```\n       */\n      skip?: boolean;\n    }\n  }\n  export type Options<\n    TVariables extends OperationVariables = OperationVariables,\n  > = Base.Options<TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    namespace useSuspenseQuery {\n      export interface Options<\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Options<TVariables>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {}\n    }\n  }\n\n  export namespace Base {\n    export interface Result<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    > {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n      client: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n      error: ErrorLike | undefined;\n\n      /**\n       * {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member}\n       *\n       * @remarks\n       * Calling this function will cause the component to re-suspend, unless the call site is wrapped in [`startTransition`](https://react.dev/reference/react/startTransition).\n       */\n      fetchMore: FetchMoreFunction<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n      networkStatus: NetworkStatus;\n\n      /**\n       * {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member}\n       *\n       * @remarks\n       * Calling this function will cause the component to re-suspend, unless the call site is wrapped in [`startTransition`](https://react.dev/reference/react/startTransition).\n       */\n      refetch: RefetchFunction<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#subscribeToMore:member} */\n      subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n    }\n  }\n  export type Result<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = Base.Result<TData, TVariables> &\n    GetDataState<MaybeMasked<TData>, TStates>;\n\n  export namespace DocumentationTypes {\n    namespace useSuspenseQuery {\n      export interface Result<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Result<TData, TVariables>,\n          UtilityDocumentationTypes.DataState<TData> {}\n    }\n  }\n  export namespace DocumentationTypes {\n    /** Test {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\n    export function useSuspenseQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options?: useSuspenseQuery.Options<TVariables>\n    ): useSuspenseQuery.Result<TData, TVariables>;\n  }\n}\n\n/**\n * For a detailed explanation of `useSuspenseQuery`, see the [fetching with Suspense reference](https://www.apollographql.com/docs/react/data/suspense).\n *\n * @example\n *\n * ```jsx\n * import { Suspense } from \"react\";\n * import { useSuspenseQuery } from \"@apollo/client\";\n *\n * const listQuery = gql`\n *   query {\n *     list {\n *       id\n *     }\n *   }\n * `;\n *\n * function App() {\n *   return (\n *     <Suspense fallback={<Spinner />}>\n *       <List />\n *     </Suspense>\n *   );\n * }\n *\n * function List() {\n *   const { data } = useSuspenseQuery(listQuery);\n *\n *   return (\n *     <ol>\n *       {data.list.map((item) => (\n *         <Item key={item.id} id={item.id} />\n *       ))}\n *     </ol>\n *   );\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - An optional object containing options for the query. Instead of passing a `useSuspenseQuery.Options` object into the hook, you can also pass a [`skipToken`](#skiptoken) to prevent the `useSuspenseQuery` hook from executing the query or suspending.\n */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useSuspenseQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"partial\" | \"empty\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useSuspenseQuery.Options<NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"empty\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useSuspenseQuery.Options<NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"empty\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useSuspenseQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"partial\" | \"streaming\" | \"complete\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useSuspenseQuery.Options<NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"empty\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (useSuspenseQuery.Options<NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"streaming\" | \"complete\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: useSuspenseQuery.Options<NoInfer<TVariables>>]\n  : [options: useSuspenseQuery.Options<NoInfer<TVariables>>]\n): useSuspenseQuery.Result<TData, TVariables, \"complete\" | \"streaming\">;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: SkipToken | useSuspenseQuery.Options<NoInfer<TVariables>>]\n  : [options: SkipToken | useSuspenseQuery.Options<NoInfer<TVariables>>]\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"empty\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken | useSuspenseQuery.Options<NoInfer<TVariables>>\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"empty\"\n>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SkipToken | useSuspenseQuery.Options<NoInfer<TVariables>>\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"streaming\" | \"complete\" | \"partial\"\n> {\n  \"use no memo\";\n  return wrapHook(\n    \"useSuspenseQuery\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useSuspenseQuery_,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options ?? ({} as any));\n}\n\nfunction useSuspenseQuery_<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<useSuspenseQuery.Options<TVariables>>)\n    | useSuspenseQuery.Options<TVariables>\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"partial\" | \"complete\" | \"streaming\" | \"empty\"\n> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions<any, any>({\n    client,\n    query,\n    options,\n  });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  let [current, setPromise] = React.useState<\n    [QueryKey, Promise<ObservableQuery.Result<any>>]\n  >([queryRef.key, queryRef.promise]);\n\n  // This saves us a re-execution of the render function when a variable changed.\n  if (current[0] !== queryRef.key) {\n    // eslint-disable-next-line react-compiler/react-compiler\n    current[0] = queryRef.key;\n    current[1] = queryRef.promise;\n  }\n  let promise = current[1];\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    current[1] = promise = queryRef.applyOptions(watchQueryOptions);\n  }\n\n  React.useEffect(() => {\n    const dispose = queryRef.retain();\n\n    const removeListener = queryRef.listen((promise) => {\n      setPromise([queryRef.key, promise]);\n    });\n\n    return () => {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n\n  const skipResult = React.useMemo<ObservableQuery.Result<TData>>(() => {\n    const error = queryRef.result.error;\n    const complete = !!queryRef.result.data;\n\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      dataState: queryRef.result.dataState,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error,\n      complete,\n      partial: !complete,\n    };\n  }, [queryRef.result]);\n\n  const result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n\n  const fetchMore = React.useCallback<\n    FetchMoreFunction<unknown, OperationVariables>\n  >(\n    (options) => {\n      const promise = queryRef.fetchMore(options);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    },\n    [queryRef]\n  ) as FetchMoreFunction<TData | undefined, TVariables>;\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  // TODO: The internalQueryRef doesn't have TVariables' type information so we have to cast it here\n  const subscribeToMore = queryRef.observable\n    .subscribeToMore as SubscribeToMoreFunction<TData | undefined, TVariables>;\n\n  return React.useMemo<\n    useSuspenseQuery.Result<TData, TVariables, DataState<TData>[\"dataState\"]>\n  >(() => {\n    return {\n      client,\n      data: result.data,\n      dataState: result.dataState,\n      error: result.error,\n      networkStatus: result.networkStatus,\n      fetchMore,\n      refetch,\n      subscribeToMore,\n    } as useSuspenseQuery.Result<\n      TData,\n      TVariables,\n      DataState<TData>[\"dataState\"]\n    >;\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\ninterface UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n> {\n  client: ApolloClient;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  options: SkipToken | useSuspenseQuery.Options<TVariables>;\n}\n\nexport function useWatchQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n>({\n  client,\n  query,\n  options,\n}: UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables\n>): ApolloClient.WatchQueryOptions<TData, TVariables> {\n  return useDeepMemo<ApolloClient.WatchQueryOptions<TData, TVariables>>(() => {\n    if (options === skipToken) {\n      return {\n        query,\n        fetchPolicy: \"standby\",\n      } as ApolloClient.WatchQueryOptions<TData, TVariables>;\n    }\n\n    const fetchPolicy =\n      options.fetchPolicy ||\n      client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\";\n\n    const watchQueryOptions: ApolloClient.WatchQueryOptions<TData, TVariables> =\n      {\n        ...options,\n        fetchPolicy,\n        query,\n        notifyOnNetworkStatusChange: false,\n        nextFetchPolicy: void 0,\n      };\n\n    if (__DEV__) {\n      validateSuspenseHookOptions(watchQueryOptions);\n    }\n\n    // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 317, "column": 0}, "map": {"version":3,"file":"useBackgroundQuery.js","sourceRoot":"","sources":["file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient%404.0.5_graphq_ce049ebab6b7b32bde04cae06d734544/node_modules/%40apollo/src/react/hooks/useBackgroundQuery.ts"],"sourcesContent":["import * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  DefaultContext,\n  DocumentNode,\n  ErrorPolicy,\n  OperationVariables,\n  RefetchWritePolicy,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport type { SubscribeToMoreFunction } from \"@apollo/client\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport type { QueryRef } from \"@apollo/client/react\";\nimport type {\n  CacheKey,\n  FetchMoreFunction,\n  RefetchFunction,\n} from \"@apollo/client/react/internal\";\nimport {\n  getSuspenseCache,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { SkipToken } from \"./constants.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\n\nexport declare namespace useBackgroundQuery {\n  import _self = useBackgroundQuery;\n  export type FetchPolicy = Extract<\n    WatchQueryFetchPolicy,\n    \"cache-first\" | \"network-only\" | \"no-cache\" | \"cache-and-network\"\n  >;\n\n  export namespace Base {\n    export interface Options {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n      client?: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy_suspense:member} */\n      refetchWritePolicy?: RefetchWritePolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n      errorPolicy?: ErrorPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n      context?: DefaultContext;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n      returnPartialData?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n      fetchPolicy?: FetchPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#queryKey:member} */\n      queryKey?: string | number | any[];\n\n      /**\n       * {@inheritDoc @apollo/client!QueryOptionsDocumentation#skip_deprecated:member}\n       *\n       * @example Recommended usage of `skipToken`:\n       *\n       * ```ts\n       * import { skipToken, useBackgroundQuery } from \"@apollo/client\";\n       *\n       * const [queryRef] = useBackgroundQuery(\n       *   query,\n       *   id ? { variables: { id } } : skipToken\n       * );\n       * ```\n       */\n      skip?: boolean;\n    }\n  }\n\n  export type Options<\n    TVariables extends OperationVariables = OperationVariables,\n  > = Base.Options & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    namespace useBackgroundQuery {\n      export interface Options<\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Options,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {}\n    }\n  }\n\n  export interface Result<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n    subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n\n    /**\n     * {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)}\n     *\n     * @remarks\n     * Calling this function will cause the component to re-suspend, unless the call site is wrapped in [`startTransition`](https://react.dev/reference/react/startTransition).\n     */\n    fetchMore: FetchMoreFunction<TData, TVariables>;\n\n    /**\n     * {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member}\n     *\n     * @remarks\n     * Calling this function will cause the component to re-suspend, unless the call site is wrapped in [`startTransition`](https://react.dev/reference/react/startTransition).\n     */\n    refetch: RefetchFunction<TData, TVariables>;\n  }\n\n  namespace DocumentationTypes {\n    namespace useBackgroundQuery {\n      export interface Result<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends _self.Result<TData, TVariables> {}\n    }\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\n    export function useBackgroundQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options: SkipToken | useBackgroundQuery.Options<TVariables>\n    ): [\n      QueryRef<TData, TVariables> | undefined,\n      useBackgroundQuery.Result<TData, TVariables>,\n    ];\n  }\n}\n\n/**\n * For a detailed explanation of useBackgroundQuery, see the [fetching with Suspense reference](https://www.apollographql.com/docs/react/data/suspense).\n *\n * @returns A tuple containing:\n *\n * 1.  A `QueryRef` that can be passed to `useReadQuery` to read the query result. The `queryRef` is `undefined` if the query is skipped.\n * 2.  An object containing helper functions for the query:\n *     - `refetch`: A function to re-execute the query\n *     - `fetchMore`: A function to fetch more results for pagination\n *     - `subscribeToMore`: A function to subscribe to updates\n *\n * @example\n *\n * ```jsx\n * import { Suspense } from \"react\";\n * import { ApolloClient, InMemoryCache, HttpLink } from \"@apollo/client\";\n * import { useBackgroundQuery, useReadQuery } from \"@apollo/client/react\";\n *\n * const query = gql`\n *   foo {\n *     bar\n *   }\n * `;\n *\n * const client = new ApolloClient({\n *   link: new HttpLink({ uri: \"http://localhost:4000/graphql\" }),\n *   cache: new InMemoryCache(),\n * });\n *\n * function SuspenseFallback() {\n *   return <div>Loading...</div>;\n * }\n *\n * function Child({ queryRef }) {\n *   const { data } = useReadQuery(queryRef);\n *\n *   return <div>{data.foo.bar}</div>;\n * }\n *\n * function Parent() {\n *   const [queryRef] = useBackgroundQuery(query);\n *\n *   return (\n *     <Suspense fallback={<SuspenseFallback />}>\n *       <Child queryRef={queryRef} />\n *     </Suspense>\n *   );\n * }\n *\n * function App() {\n *   return (\n *     <ApolloProvider client={client}>\n *       <Parent />\n *     </ApolloProvider>\n *   );\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - An optional object containing options for the query. Instead of passing a `useBackgroundQuery.Options` object into the hook, you can also pass a [`skipToken`](#skiptoken) to prevent the `useBackgroundQuery` hook from executing the query or suspending.\n */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    /** @deprecated `returnPartialData` has no effect on `no-cache` queries */\n    returnPartialData: boolean;\n    fetchPolicy: \"no-cache\";\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: false;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"empty\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: boolean;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\" | \"empty\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"empty\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: false;\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: boolean;\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: false;\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: boolean;\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken\n): [undefined, useBackgroundQuery.Result<TData, TVariables>];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (useBackgroundQuery.Options<NoInfer<TVariables>> & {\n        returnPartialData: false;\n      })\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (useBackgroundQuery.Options<NoInfer<TVariables>> & {\n        returnPartialData: boolean;\n      })\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: useBackgroundQuery.Options<NoInfer<TVariables>>]\n  : [options: useBackgroundQuery.Options<NoInfer<TVariables>>]\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: SkipToken | useBackgroundQuery.Options<NoInfer<TVariables>>]\n  : [options: SkipToken | useBackgroundQuery.Options<NoInfer<TVariables>>]\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken | useBackgroundQuery.Options<NoInfer<TVariables>>\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SkipToken | useBackgroundQuery.Options<NoInfer<TVariables>>\n): [\n  QueryRef<TData, TVariables, DataState<TData>[\"dataState\"]> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n] {\n  \"use no memo\";\n  return wrapHook(\n    \"useBackgroundQuery\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useBackgroundQuery_,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options ?? ({} as any));\n}\n\nfunction useBackgroundQuery_<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<useBackgroundQuery.Options<NoInfer<TVariables>>>)\n    | useBackgroundQuery.Options<NoInfer<TVariables>>\n): [\n  QueryRef<TData, TVariables, TStates> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n] {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n  const didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current ||= fetchPolicy !== \"standby\";\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef<TData, TStates>(cacheKey, () =>\n    client.watchQuery(\n      watchQueryOptions as ApolloClient.WatchQueryOptions<any, any>\n    )\n  );\n\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(\n    wrapQueryRef(queryRef)\n  );\n  if (unwrapQueryRef(wrappedQueryRef) !== queryRef) {\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n  }\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    const promise = queryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(wrappedQueryRef, promise);\n  }\n\n  // This prevents issues where rerendering useBackgroundQuery after the\n  // queryRef has been disposed would cause the hook to return a new queryRef\n  // instance since disposal also removes it from the suspense cache. We add\n  // the queryRef back in the suspense cache so that the next render will reuse\n  // this queryRef rather than initializing a new instance.\n  React.useEffect(() => {\n    // Since the queryRef is disposed async via `setTimeout`, we have to wait a\n    // tick before checking it and adding back to the suspense cache.\n    const id = setTimeout(() => {\n      if (queryRef.disposed) {\n        suspenseCache.add(cacheKey, queryRef);\n      }\n    });\n\n    return () => clearTimeout(id);\n    // Omitting the deps is intentional. This avoids stale closures and the\n    // conditional ensures we aren't running the logic on each render.\n  });\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = queryRef.fetchMore(options);\n\n      setWrappedQueryRef(wrapQueryRef(queryRef));\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(queryRef));\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  React.useEffect(() => queryRef.softRetain(), [queryRef]);\n\n  return [\n    didFetchResult.current ? wrappedQueryRef : void 0,\n    {\n      fetchMore,\n      refetch,\n      // TODO: The internalQueryRef doesn't have TVariables' type information so we have to cast it here\n      subscribeToMore: queryRef.observable\n        .subscribeToMore as SubscribeToMoreFunction<TData, TVariables>,\n    },\n  ];\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 420, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/SimulatePreloadedQuery.cc.ts","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/transportedQueryRef.ts","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/ReadableStreamLink.tsx","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/DataTransportAbstraction/WrappedInMemoryCache.tsx","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/bundleInfo.ts","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/DataTransportAbstraction/WrappedApolloClient.tsx","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/DataTransportAbstraction/useTransportValue.tsx","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/DataTransportAbstraction/DataTransportAbstraction.ts","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/DataTransportAbstraction/hooks.ts","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/DataTransportAbstraction/transportedOptions.ts","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/assertInstance.ts","file:///C:/Users/Jonao/Documents/Projeto/ecommerce-monorepo/node_modules/.pnpm/%40apollo%2Bclient-react-stream_e3caac786fca2dc6f3892c17c4b6e8fe/node_modules/%40apollo/client-react-streaming/src/DataTransportAbstraction/WrapApolloProvider.tsx"],"sourcesContent":["\"use client\";\n\nimport { useApolloClient, useBackgroundQuery } from \"@apollo/client/react\";\nimport { useMemo, type ReactNode } from \"react\";\nimport {\n  reviveTransportedQueryRef,\n  type TransportedQueryRef,\n} from \"./transportedQueryRef.js\";\nimport { deserializeOptions } from \"./DataTransportAbstraction/transportedOptions.js\";\nimport type { PreloadQueryOptions } from \"./PreloadQuery.js\";\n\nexport default function SimulatePreloadedQuery<T>({\n  queryRef,\n  children,\n}: {\n  queryRef: TransportedQueryRef<T>;\n  children: ReactNode;\n}) {\n  const client = useApolloClient();\n  reviveTransportedQueryRef(queryRef, client);\n\n  const bgQueryArgs = useMemo<Parameters<typeof useBackgroundQuery>>(() => {\n    const { query, ...hydratedOptions } = deserializeOptions(\n      queryRef.$__apollo_queryRef.options\n    ) as PreloadQueryOptions<any, T>;\n    return [\n      query,\n      { ...hydratedOptions, queryKey: queryRef.$__apollo_queryRef.queryKey },\n    ] as const;\n  }, [queryRef.$__apollo_queryRef]);\n\n  useBackgroundQuery(...bgQueryArgs);\n\n  return children;\n}\n","import type { CacheKey } from \"@apollo/client/react/internal\";\nimport {\n  getSuspenseCache,\n  unwrapQueryRef,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal\";\nimport {\n  readFromReadableStream,\n  teeToReadableStream,\n} from \"./ReadableStreamLink.js\";\nimport { skipDataTransport } from \"./DataTransportAbstraction/index.js\";\nimport type { ReadableStreamLinkEvent } from \"./ReadableStreamLink.js\";\nimport type { QueryRef } from \"@apollo/client/react\";\nimport { useApolloClient } from \"@apollo/client/react\";\nimport type {\n  DocumentNode,\n  ApolloClient,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport {\n  serializeOptions,\n  deserializeOptions,\n  type TransportedOptions,\n} from \"./DataTransportAbstraction/transportedOptions.js\";\nimport { useEffect } from \"react\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport {\n  JSONDecodeStream,\n  JSONEncodeStream,\n  type JsonString,\n} from \"@apollo/client-react-streaming/stream-utils\";\n\ntype RestrictedPreloadOptions = {\n  fetchPolicy?: \"network-only\" | \"cache-and-network\" | \"cache-first\";\n  returnPartialData?: false;\n  nextFetchPolicy?: undefined;\n  pollInterval?: undefined;\n};\n\n/** @public */\nexport type PreloadTransportedQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n> = Omit<ApolloClient.QueryOptions<TData, TVariables>, \"query\"> &\n  RestrictedPreloadOptions;\n\ntype TransportedQueryRefOptions = TransportedOptions & RestrictedPreloadOptions;\n\n/**\n * A `TransportedQueryRef` is an opaque object accessible via renderProp within `PreloadQuery`.\n *\n * A child client component reading the `TransportedQueryRef` via useReadQuery will suspend until the promise resolves.\n *\n * @public\n */\nexport interface TransportedQueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> extends QueryRef<TData, TVariables> {\n  /**\n   * Temporarily disabled - see https://github.com/apollographql/apollo-client-integrations/issues/332\n   *\n   * Will now be be `undefined` both in React Server Components and Client Components until we can find a better resolution.\n   */\n  toPromise?: undefined;\n  /** @internal */\n  $__apollo_queryRef: {\n    options: TransportedQueryRefOptions;\n    stream: ReadableStream<JsonString<ReadableStreamLinkEvent>>;\n    /**\n     * A unique key for this query, to ensure it is only hydrated once,\n     * even if it should get transported over the wire in a way that results\n     * in multiple objects describing the same queryRef.\n     * This key will be used to store the queryRef in the suspence cache.\n     *\n     * The chances of this happening should be slim (it is handled within\n     * React thanks to https://github.com/facebook/react/pull/28996), but\n     * as we use transported queryRefs with multiple frameworks with distinct\n     * transport mechanisms, this seems like a safe option.\n     */\n    queryKey: string;\n  };\n}\n\n/** @public */\nexport interface PreloadTransportedQueryFunction {\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options?: PreloadTransportedQueryOptions<TData, NoInfer<TVariables>>\n  ): TransportedQueryRef<TData, TVariables>;\n}\n\n/** @internal */\nexport function getInjectableEventStream() {\n  let controller:\n    | ReadableStreamDefaultController<ReadableStreamLinkEvent>\n    | undefined;\n  const stream = new ReadableStream<ReadableStreamLinkEvent>({\n    start(c) {\n      controller = c;\n    },\n  });\n  return [controller!, stream] as const;\n}\n\n/** @public */\nexport function createTransportedQueryPreloader(\n  client: ApolloClient\n): PreloadTransportedQueryFunction {\n  return (...[query, options]: Parameters<PreloadTransportedQueryFunction>) => {\n    // unset options that we do not support\n    options = { ...options };\n    delete options.returnPartialData;\n    delete options.nextFetchPolicy;\n    delete options.pollInterval;\n\n    const [controller, stream] = getInjectableEventStream();\n\n    // Instead of creating the queryRef, we kick off a query that will feed the network response\n    // into our custom event stream.\n    client\n      .query({\n        query,\n        ...options,\n        // ensure that this query makes it to the network\n        fetchPolicy: \"no-cache\",\n        context: skipDataTransport(\n          teeToReadableStream(() => controller, {\n            ...options?.context,\n            // we want to do this even if the query is already running for another reason\n            queryDeduplication: false,\n          })\n        ),\n      })\n      .catch(() => {\n        /* we want to avoid any floating promise rejections */\n      });\n\n    return createTransportedQueryRef<any, any>(\n      query,\n      options,\n      crypto.randomUUID(),\n      stream\n    );\n  };\n}\n\nfunction createTransportedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: PreloadTransportedQueryOptions<TData, NoInfer<TVariables>>,\n  queryKey: string,\n  stream: ReadableStream<ReadableStreamLinkEvent>\n): TransportedQueryRef<TData, TVariables> {\n  return {\n    $__apollo_queryRef: {\n      options: sanitizeForTransport(serializeOptions({ query, ...options })),\n      queryKey,\n      stream: stream.pipeThrough(new JSONEncodeStream()),\n    },\n  };\n}\n\nconst hydrationCache = new WeakMap<\n  TransportedQueryRef,\n  { cacheKey: CacheKey }\n>();\n\n/** @public */\nexport function reviveTransportedQueryRef(\n  queryRef: TransportedQueryRef,\n  client: ApolloClient\n): asserts queryRef is TransportedQueryRef & ReturnType<typeof wrapQueryRef> {\n  const {\n    $__apollo_queryRef: { options, stream, queryKey },\n  } = queryRef;\n  if (!hydrationCache.has(queryRef)) {\n    const hydratedOptions = deserializeOptions(options);\n    const cacheKey: CacheKey = [\n      hydratedOptions.query,\n      canonicalStringify(hydratedOptions.variables),\n      queryKey,\n    ];\n    hydrationCache.set(queryRef, { cacheKey });\n    const internalQueryRef = getSuspenseCache(client).getQueryRef(\n      cacheKey,\n      () =>\n        client.watchQuery({\n          ...hydratedOptions,\n          fetchPolicy: \"network-only\",\n          context: skipDataTransport(\n            readFromReadableStream(stream.pipeThrough(new JSONDecodeStream()), {\n              ...hydratedOptions.context,\n              queryDeduplication: true,\n            })\n          ),\n        })\n    );\n    Object.assign(queryRef, wrapQueryRef(internalQueryRef));\n  }\n}\n\n/** @public */\nexport function isTransportedQueryRef(\n  queryRef: any\n): queryRef is TransportedQueryRef {\n  return !!(queryRef && queryRef.$__apollo_queryRef);\n}\n\n/** @public */\nexport function useWrapTransportedQueryRef<TData>(\n  queryRef:\n    | QueryRef<TData, any, \"complete\" | \"streaming\" | \"empty\" | \"partial\">\n    | TransportedQueryRef\n): QueryRef<TData> {\n  const client = useApolloClient();\n  let cacheKey: CacheKey | undefined;\n  let isTransported: boolean;\n  if ((isTransported = isTransportedQueryRef(queryRef))) {\n    reviveTransportedQueryRef(queryRef, client);\n    cacheKey = hydrationCache.get(queryRef)?.cacheKey;\n  }\n  const unwrapped = unwrapQueryRef(queryRef)!;\n\n  useEffect(() => {\n    // We only want this to execute if the queryRef is a transported query.\n    if (!isTransported) return;\n    // We want to always keep this queryRef in the suspense cache in case another component has another instance of this transported queryRef.\n    if (cacheKey) {\n      if (unwrapped.disposed) {\n        getSuspenseCache(client).add(cacheKey, unwrapped);\n      }\n    }\n    // Omitting the deps is intentional. This avoids stale closures and the\n    // conditional ensures we aren't running the logic on each render.\n  });\n  // Soft-retaining because useQueryRefHandlers doesn't do it for us.\n  useEffect(() => {\n    if (isTransported) {\n      return unwrapped.softRetain();\n    }\n  }, [isTransported, unwrapped]);\n  return queryRef satisfies QueryRef<any, any, any> as QueryRef<TData>;\n}\n\nfunction sanitizeForTransport<T>(value: T) {\n  return JSON.parse(JSON.stringify(value)) as T;\n}\n","import { ApolloLink, Observable } from \"@apollo/client\";\n\n/**\n * @internal\n */\nexport type ReadableStreamLinkEvent =\n  | { type: \"next\"; value: ApolloLink.Result }\n  | { type: \"completed\" }\n  | { type: \"error\" };\n\n/**\n * Called when the link is hit, before the request is forwarded.\n *\n * Should return the controller for the readable stream.\n *\n * This is useful because when starting a query, it's not always\n * clear if the query will hit the network or will be served from\n * cache, deduplicated etc.\n * This allows to inject the \"start event\" into the stream only\n * when we know that more chunks will actually follow.\n */\ntype OnLinkHitFunction =\n  () => ReadableStreamDefaultController<ReadableStreamLinkEvent>;\ninterface InternalContext {\n  [teeToReadableStreamKey]?: OnLinkHitFunction;\n  [readFromReadableStreamKey]?: ReadableStream<ReadableStreamLinkEvent>;\n}\n\nconst teeToReadableStreamKey = Symbol.for(\n  \"apollo.tee.readableStreamController\"\n);\nconst readFromReadableStreamKey = Symbol.for(\"apollo.read.readableStream\");\n\n/**\n * Apply to a context that will be passed to a link chain containing `TeeToReadableStreamLink`.\n * @public\n */\nexport function teeToReadableStream<T extends Record<string, any>>(\n  onLinkHit: OnLinkHitFunction,\n  context: T\n): T & InternalContext {\n  return Object.assign(context, {\n    [teeToReadableStreamKey]: onLinkHit,\n  });\n}\n\n/**\n * Apply to a context that will be passed to a link chain containing `ReadFromReadableStreamLink`.\n * @public\n */\nexport function readFromReadableStream<T extends Record<string, any>>(\n  readableStream: ReadableStream<ReadableStreamLinkEvent>,\n  context: T\n): T & InternalContext {\n  return Object.assign(context, {\n    [readFromReadableStreamKey]: readableStream,\n  });\n}\n\n/**\n * A link that allows the request to be cloned into a readable stream, e.g. for\n * transport of multipart responses from RSC or a server loader to the browser.\n * @public\n */\nexport class TeeToReadableStreamLink extends ApolloLink {\n  constructor() {\n    super((operation, forward) => {\n      const context = operation.getContext() as InternalContext;\n\n      const onLinkHit = context[teeToReadableStreamKey];\n\n      if (onLinkHit) {\n        const controller = onLinkHit();\n\n        const tryClose = () => {\n          try {\n            controller.close();\n          } catch {\n            // maybe we already tried to close the stream, nothing to worry about\n          }\n        };\n        return new Observable((observer) => {\n          const subscription = forward(operation).subscribe({\n            next(result) {\n              controller.enqueue({ type: \"next\", value: result });\n              observer.next(result);\n            },\n            error(error) {\n              controller.enqueue({ type: \"error\" });\n              tryClose();\n              observer.error(error);\n            },\n            complete() {\n              controller.enqueue({ type: \"completed\" });\n              tryClose();\n              observer.complete();\n            },\n          });\n\n          return () => {\n            tryClose();\n            subscription.unsubscribe();\n          };\n        });\n      }\n\n      return forward(operation);\n    });\n  }\n}\n\n/**\n * A link that allows the response to be read from a readable stream, e.g. for\n * hydration of a multipart response from RSC or a server loader in the browser.\n * @public\n */\nexport class ReadFromReadableStreamLink extends ApolloLink {\n  constructor() {\n    super((operation, forward) => {\n      const context = operation.getContext() as InternalContext;\n\n      const eventSteam = context[readFromReadableStreamKey];\n      if (eventSteam) {\n        return new Observable((observer) => {\n          let aborted = false as boolean;\n          const reader = (() => {\n            try {\n              return eventSteam.getReader();\n            } catch {\n              /**\n               * The reader could not be created, usually because the stream has\n               * already been consumed.\n               * This would be the case if we call `refetch` on a queryRef that has\n               * the `readFromReadableStreamKey` property in context.\n               * In that case, we want to do a normal network request.\n               */\n            }\n          })();\n\n          if (!reader) {\n            // if we can't create a reader, we want to do a normal network request\n            const subscription = forward(operation).subscribe(observer);\n            return () => subscription.unsubscribe();\n          }\n          consume(reader);\n\n          let onAbort = () => {\n            aborted = true;\n            reader.cancel();\n          };\n\n          return () => onAbort();\n\n          async function consume(\n            reader: ReadableStreamDefaultReader<ReadableStreamLinkEvent>\n          ) {\n            let event:\n              | ReadableStreamReadResult<ReadableStreamLinkEvent>\n              | undefined = undefined;\n            while (!aborted && !event?.done) {\n              event = await reader.read();\n              if (aborted) break;\n              if (event.value) {\n                switch (event.value.type) {\n                  case \"next\":\n                    observer.next(event.value.value);\n                    break;\n                  case \"completed\":\n                    observer.complete();\n                    break;\n                  case \"error\":\n                    // in case a network error happened on the sending side,\n                    if (process.env.REACT_ENV === \"ssr\") {\n                      // we want to fail SSR for this tree\n                      observer.error(\n                        new Error(\n                          \"Error from event stream. Redacted for security concerns.\"\n                        )\n                      );\n                    } else {\n                      // we want to retry the operation on the receiving side\n                      onAbort();\n                      const subscription =\n                        forward(operation).subscribe(observer);\n                      onAbort = () => subscription.unsubscribe();\n                    }\n                    break;\n                }\n              }\n            }\n          }\n        });\n      }\n\n      return forward(operation);\n    });\n  }\n}\n","import type { InMemoryCacheConfig } from \"@apollo/client\";\nimport { InMemoryCache as OrigInMemoryCache } from \"@apollo/client\";\nimport { bundle, sourceSymbol } from \"../bundleInfo.js\";\n/*\n * We just subclass `InMemoryCache` here so that `WrappedApolloClient`\n * can detect if it was initialized with an `InMemoryCache` instance that\n * was also exported from this package.\n * Right now, we don't have extra logic here, but we might have so again\n * in the future.\n * So we want to enforce this import path from the start to prevent future\n * subtle bugs if people update the package and don't read the patch notes.\n */\n/**\n * A version of `InMemoryCache` to be used with streaming SSR.\n *\n * For more documentation, please see {@link https://www.apollographql.com/docs/react/api/cache/InMemoryCache | the Apollo Client API documentation}.\n *\n * @public\n */\nexport class InMemoryCache extends OrigInMemoryCache {\n  /**\n   * Information about the current package and it's export names, for use in error messages.\n   *\n   * @internal\n   */\n  static readonly info = bundle;\n  [sourceSymbol]: string;\n  constructor(config?: InMemoryCacheConfig | undefined) {\n    super(config);\n    const info = (this.constructor as typeof InMemoryCache).info;\n    this[sourceSymbol] = `${info.pkg}:InMemoryCache`;\n  }\n}\n","export const bundle = {\n  pkg: \"@apollo/client-react-streaming\",\n};\n\nexport const sourceSymbol = Symbol.for(\"apollo.source_package\");\n","import type { OperationVariables } from \"@apollo/client\";\n\nimport {\n  ApolloLink,\n  ApolloClient as OrigApolloClient,\n  Observable,\n  type InternalTypes,\n} from \"@apollo/client\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\nimport { createBackpressuredCallback } from \"./backpressuredCallback.js\";\nimport type { InMemoryCache } from \"./WrappedInMemoryCache.js\";\nimport { hookWrappers } from \"./hooks.js\";\nimport type { HookWrappers } from \"@apollo/client/react/internal\";\nimport type {\n  ProgressEvent,\n  QueryEvent,\n  TransportIdentifier,\n} from \"./DataTransportAbstraction.js\";\nimport { bundle, sourceSymbol } from \"../bundleInfo.js\";\nimport { serializeOptions, deserializeOptions } from \"./transportedOptions.js\";\nimport { assertInstance } from \"../assertInstance.js\";\nimport type { ReadableStreamLinkEvent } from \"../ReadableStreamLink.js\";\nimport {\n  readFromReadableStream,\n  ReadFromReadableStreamLink,\n  teeToReadableStream,\n  TeeToReadableStreamLink,\n} from \"../ReadableStreamLink.js\";\nimport { getInjectableEventStream } from \"../transportedQueryRef.js\";\n\nfunction getQueryManager(\n  client: OrigApolloClient\n): InternalTypes.QueryManager & {\n  [wrappers]: HookWrappers;\n} {\n  return client[\"queryManager\"];\n}\n\ntype SimulatedQueryInfo = {\n  controller: ReadableStreamDefaultController<ReadableStreamLinkEvent>;\n  options: OrigApolloClient.WatchQueryOptions<any, OperationVariables>;\n};\n/** @public */\nexport declare namespace ApolloClient {\n  /** @public */\n  export interface Options\n    extends Omit<\n      OrigApolloClient.Options,\n      \"cache\" | \"ssrMode\" | \"ssrForceFetchDelay\"\n    > {\n    cache: InMemoryCache;\n  }\n  /*\n  We can currently not re-export these types from the upstream ApolloClient implementation because the build \n  tooling doesn't support that:\n    > DTS Build error\n    > Error: namespace child (hoisting) not supported yet\n\n    We could re-export them by defining them as new types that reference the originals, but that would require us\n    to keep generics in sync and would either erase the docblocks or require us to duplicate them \n    (and they would go out of sync).\n    If you need any of the other types, please use the `ApolloClient` namespace exported from `@apollo/client` directly.\n  */\n  // export import DefaultOptions = OrigApolloClient.DefaultOptions;\n  // export import DevtoolsOptions = OrigApolloClient.DevtoolsOptions;\n  // export import MutateOptions = OrigApolloClient.MutateOptions;\n  // export import MutateResult = OrigApolloClient.MutateResult;\n  // export import QueryOptions = OrigApolloClient.QueryOptions;\n  // export import QueryResult = OrigApolloClient.QueryResult;\n  // export import RefetchQueriesOptions = OrigApolloClient.RefetchQueriesOptions;\n  // export import RefetchQueriesResult = OrigApolloClient.RefetchQueriesResult;\n  // export import SubscribeOptions = OrigApolloClient.SubscribeOptions;\n  // export import SubscribeResult = OrigApolloClient.SubscribeResult;\n  // export import WatchFragmentOptions = OrigApolloClient.WatchFragmentOptions;\n  // export import WatchFragmentResult = OrigApolloClient.WatchFragmentResult;\n  // export import WatchQueryOptions = OrigApolloClient.WatchQueryOptions;\n  // export import ReadQueryOptions = OrigApolloClient.ReadQueryOptions;\n  // export import WriteQueryOptions = OrigApolloClient.WriteQueryOptions;\n  // export import WriteFragmentOptions = OrigApolloClient.WriteFragmentOptions;\n}\n\nconst wrappers = Symbol.for(\"apollo.hook.wrappers\");\nclass ApolloClientBase extends OrigApolloClient {\n  /**\n   * Information about the current package and it's export names, for use in error messages.\n   *\n   * @internal\n   */\n  static readonly info = bundle;\n\n  [sourceSymbol]: string;\n\n  constructor(options: ApolloClient.Options) {\n    const warnings: string[] = [];\n    if (\"ssrMode\" in options) {\n      delete options.ssrMode;\n      warnings.push(\n        \"The `ssrMode` option is not supported in %s. Please remove it from your %s constructor options.\"\n      );\n    }\n    if (\"ssrForceFetchDelay\" in options) {\n      delete options.ssrForceFetchDelay;\n      warnings.push(\n        \"The `ssrForceFetchDelay` option is not supported in %s. Please remove it from your %s constructor options.\"\n      );\n    }\n    super(\n      process.env.REACT_ENV === \"rsc\" || process.env.REACT_ENV === \"ssr\"\n        ? {\n            devtools: { enabled: false, ...options.devtools },\n            ...options,\n          }\n        : options\n    );\n    const info = (this.constructor as typeof ApolloClientBase).info;\n    this[sourceSymbol] = `${info.pkg}:ApolloClient`;\n\n    for (const warning of warnings) {\n      console.warn(warning, info.pkg, \"ApolloClient\");\n    }\n\n    assertInstance(\n      this.cache as unknown as InMemoryCache,\n      info,\n      \"InMemoryCache\"\n    );\n\n    this.setLink(this.link);\n  }\n\n  setLink(newLink: ApolloLink) {\n    super.setLink.call(\n      this,\n      ApolloLink.from([\n        new ReadFromReadableStreamLink(),\n        new TeeToReadableStreamLink(),\n        newLink,\n      ])\n    );\n  }\n}\n\nclass ApolloClientClientBaseImpl extends ApolloClientBase {\n  constructor(options: ApolloClient.Options) {\n    super(options);\n    this.onQueryStarted = this.onQueryStarted.bind(this);\n\n    getQueryManager(this)[wrappers] = hookWrappers;\n  }\n\n  private simulatedStreamingQueries = new Map<\n    TransportIdentifier,\n    SimulatedQueryInfo\n  >();\n\n  onQueryStarted({ options, id }: Extract<QueryEvent, { type: \"started\" }>) {\n    const hydratedOptions = deserializeOptions(options);\n\n    const [controller, stream] = getInjectableEventStream();\n\n    const queryManager = getQueryManager(this);\n    queryManager.fetchQuery({\n      ...hydratedOptions,\n      query: queryManager.transform(hydratedOptions.query),\n      fetchPolicy: \"network-only\",\n      context: skipDataTransport(\n        readFromReadableStream(stream, {\n          ...hydratedOptions.context,\n          queryDeduplication: true,\n        })\n      ),\n    });\n\n    this.simulatedStreamingQueries.set(id, {\n      controller,\n      options: hydratedOptions,\n    });\n  }\n\n  onQueryProgress = (event: ProgressEvent) => {\n    const queryInfo = this.simulatedStreamingQueries.get(event.id);\n    if (!queryInfo) return;\n\n    if (\n      event.type === \"error\" ||\n      (event.type === \"next\" && event.value.errors)\n    ) {\n      /**\n       * At this point we're not able to correctly serialize the error over the wire\n       * so we do the next-best thing: restart the query in the browser as soon as it\n       * failed on the server.\n       * This matches up with what React will be doing (abort hydration and rerender)\n       * See https://github.com/apollographql/apollo-client-integrations/issues/52\n       */\n      this.simulatedStreamingQueries.delete(event.id);\n      if (process.env.REACT_ENV === \"browser\") {\n        invariant.debug(\n          \"Query failed on server, rerunning in browser:\",\n          queryInfo.options\n        );\n        this.rerunSimulatedQuery(queryInfo);\n      } else if (process.env.REACT_ENV === \"ssr\") {\n        invariant.debug(\n          \"Query failed upstream, will fail it during SSR and rerun it in the browser:\",\n          queryInfo.options\n        );\n        queryInfo.controller.error(new Error(\"Query failed upstream.\"));\n      }\n    } else if (event.type === \"completed\") {\n      this.simulatedStreamingQueries.delete(event.id);\n      queryInfo.controller.enqueue(event);\n    } else if (event.type === \"next\") {\n      queryInfo.controller.enqueue(event);\n    }\n  };\n\n  /**\n   * Can be called when the stream closed unexpectedly while there might still be unresolved\n   * simulated server-side queries going on.\n   * Those queries will be cancelled and then re-run in the browser.\n   */\n  rerunSimulatedQueries = () => {\n    for (const [id, queryInfo] of this.simulatedStreamingQueries) {\n      this.simulatedStreamingQueries.delete(id);\n      invariant.debug(\n        \"streaming connection closed before server query could be fully transported, rerunning:\",\n        queryInfo.options\n      );\n      this.rerunSimulatedQuery(queryInfo);\n    }\n  };\n  rerunSimulatedQuery = (queryInfo: SimulatedQueryInfo) => {\n    const queryManager = getQueryManager(this);\n    queryManager.fetchQuery({\n      ...queryInfo.options,\n      fetchPolicy: \"no-cache\",\n      query: queryManager.transform(queryInfo.options.query),\n      context: skipDataTransport(\n        teeToReadableStream(() => queryInfo.controller, {\n          ...queryInfo.options.context,\n          queryDeduplication: false,\n        })\n      ),\n    });\n  };\n}\n\nconst skipDataTransportKey = Symbol.for(\"apollo.dataTransport.skip\");\ninterface InternalContext {\n  [skipDataTransportKey]?: boolean;\n}\n\n/**\n * Apply to a context to prevent this operation from being transported over the SSR data transport mechanism.\n * @public\n */\nexport function skipDataTransport<T extends Record<string, any>>(\n  context: T\n): T & InternalContext {\n  return Object.assign(context, {\n    [skipDataTransportKey]: true,\n  });\n}\n\nclass ApolloClientSSRImpl extends ApolloClientClientBaseImpl {\n  watchQueryQueue = createBackpressuredCallback<{\n    event: Extract<QueryEvent, { type: \"started\" }>;\n    observable: Observable<Exclude<QueryEvent, { type: \"started\" }>>;\n  }>();\n\n  pushEventStream(\n    options: OrigApolloClient.WatchQueryOptions<any, any>\n  ): ReadableStreamDefaultController<ReadableStreamLinkEvent> {\n    const id = crypto.randomUUID() as TransportIdentifier;\n\n    const [controller, eventStream] = getInjectableEventStream();\n\n    const streamObservable = new Observable<\n      Exclude<QueryEvent, { type: \"started\" }>\n    >((subscriber) => {\n      function consume(\n        event: ReadableStreamReadResult<ReadableStreamLinkEvent>\n      ) {\n        const value = event.value;\n        if (value) {\n          subscriber.next({ ...value, id });\n        }\n        if (event.done) {\n          subscriber.complete();\n        } else {\n          reader.read().then(consume);\n        }\n      }\n      const reader = eventStream.getReader();\n      reader.read().then(consume);\n    });\n\n    this.watchQueryQueue.push({\n      event: {\n        type: \"started\",\n        options: serializeOptions(options),\n        id,\n      },\n      observable: streamObservable,\n    });\n\n    return controller;\n  }\n\n  watchQuery<\n    TData = any,\n    TVariables extends OperationVariables = OperationVariables,\n  >(options: OrigApolloClient.WatchQueryOptions<TData, TVariables>) {\n    if (\n      !(options.context as InternalContext | undefined)?.[skipDataTransportKey]\n    ) {\n      return super.watchQuery({\n        ...options,\n        context: teeToReadableStream(\n          () =>\n            this.pushEventStream(\n              options as OrigApolloClient.WatchQueryOptions<any, any>\n            ),\n          {\n            ...options?.context,\n          }\n        ),\n      });\n    }\n    return super.watchQuery(options);\n  }\n}\n\nclass ApolloClientBrowserImpl extends ApolloClientClientBaseImpl {}\n\nclass ApolloClientRSCImpl extends ApolloClientBase {}\n\nconst ApolloClientImplementation =\n  /*#__PURE__*/ process.env.REACT_ENV === \"ssr\"\n    ? ApolloClientSSRImpl\n    : process.env.REACT_ENV === \"browser\"\n      ? ApolloClientBrowserImpl\n      : ApolloClientRSCImpl;\n\n/**\n * A version of `ApolloClient` to be used with streaming SSR or in React Server Components.\n *\n * For more documentation, please see {@link https://www.apollographql.com/docs/react/api/core/ApolloClient | the Apollo Client API documentation}.\n *\n * @public\n */\nexport class ApolloClient\n  extends (ApolloClientImplementation as typeof ApolloClientBase)\n  implements Partial<ApolloClientSSRImpl>\n{\n  /** @internal */\n  declare onQueryStarted?: ApolloClientSSRImpl[\"onQueryStarted\"];\n  /** @internal */\n  declare onQueryProgress?: ApolloClientSSRImpl[\"onQueryProgress\"];\n  /** @internal */\n  declare rerunSimulatedQueries?: ApolloClientSSRImpl[\"rerunSimulatedQueries\"];\n  /** @internal */\n  declare rerunSimulatedQuery?: ApolloClientSSRImpl[\"rerunSimulatedQuery\"];\n  /** @internal */\n  declare watchQueryQueue?: ApolloClientSSRImpl[\"watchQueryQueue\"];\n}\n","\"use client\";\nimport { useContext, useSyncExternalStore } from \"react\";\nimport { DataTransportContext } from \"./DataTransportAbstraction.js\";\nimport { equal } from \"@wry/equality\";\n\nconst CLEAN = {};\nconst enum WhichResult {\n  client,\n  server,\n}\n\n/**\n * A hook that mostly acts as an identity function.\n * It will only behave differently during\n * the first render on the client, in which case it will\n * try to return the last value it was called with by\n * the same component during SSR. If that is successful,\n * it will schedule another rerender, to after hydration\n * the component can change to client-side values instead.\n */\nexport function useTransportValue<T>(value: T): T {\n  const dataTransport = useContext(DataTransportContext);\n  if (!dataTransport)\n    throw new Error(\n      \"useTransportValue must be used within a streaming-specific ApolloProvider\"\n    );\n  const valueRef = dataTransport.useStaticValueRef<T | typeof CLEAN>(value);\n\n  const whichResult = useSyncExternalStore(\n    () => () => {},\n    () => WhichResult.client,\n    () =>\n      valueRef.current === CLEAN\n        ? WhichResult.client\n        : equal(value, valueRef.current)\n          ? WhichResult.client\n          : WhichResult.server\n  );\n\n  if (whichResult === WhichResult.client) {\n    // this value will never be used again\n    // so we can safely delete it to save memory\n    valueRef.current = CLEAN;\n  }\n\n  return whichResult === WhichResult.server ? (valueRef.current as T) : value;\n}\n","import type React from \"react\";\nimport type { Observable } from \"@apollo/client\";\nimport { createContext } from \"react\";\nimport type { TransportedOptions } from \"./transportedOptions.js\";\nimport type { ReadableStreamLinkEvent } from \"../ReadableStreamLink.ts\";\n\ninterface DataTransportAbstraction {\n  /**\n   * This hook should always return the first value it was called with.\n   *\n   * If used in the browser and SSR happened, it should return the value passed to it on the server.\n   */\n  useStaticValueRef<T>(value: T): { current: T };\n}\n\n/**\n * > This export is only available in React Client Components\n *\n * If you create a custom data transport, you need to wrap the child tree in a\n * `DataTransportContext.Provider` and provide the `DataTransportAbstraction` to it.\n *\n * See for example\n * https://github.com/apollographql/apollo-client-integrations/blob/37feeaa9aea69b90a974eb9cd0fbd636b62d841a/integration-test/experimental-react/src/WrappedApolloProvider.tsx\n *\n * @public\n */\nexport const DataTransportContext =\n  /*#__PURE__*/ createContext<DataTransportAbstraction | null>(null);\n\n/**\n * Interface to be implemented by a custom data transport component,\n * for usage with `WrapApolloProvider`.\n *\n * This component needs to provide a `DataTransportContext` to it's children.\n *\n * See for example\n * https://github.com/apollographql/apollo-client-integrations/blob/37feeaa9aea69b90a974eb9cd0fbd636b62d841a/integration-test/experimental-react/src/WrappedApolloProvider.tsx\n *\n * @public\n */\nexport type DataTransportProviderImplementation<\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  ExtraProps = {},\n> = React.FC<\n  {\n    /** will be present in the Browser */\n    onQueryEvent?: (event: QueryEvent) => void;\n    /** will be present in the Browser */\n    rerunSimulatedQueries?: () => void;\n    /** will be present during SSR */\n    registerDispatchRequestStarted?: (\n      callback: (query: {\n        event: Extract<QueryEvent, { type: \"started\" }>;\n        observable: Observable<Exclude<QueryEvent, { type: \"started\" }>>;\n      }) => void\n    ) => void;\n    /** will always be present */\n    children: React.ReactNode;\n  } & ExtraProps\n>;\n\nexport type TransportIdentifier = string & { __transportIdentifier: true };\n\n/**\n * Events that will be emitted by a wrapped ApolloClient instance during\n * SSR on `DataTransportProviderImplementation.registerDispatchRequestStarted`,\n * to be transported to the browser and replayed there using\n * `DataTransportProviderImplementation.onQueryEvent`.\n *\n * @public\n */\nexport type QueryEvent =\n  | {\n      type: \"started\";\n      options: TransportedOptions;\n      id: TransportIdentifier;\n    }\n  | (ReadableStreamLinkEvent & {\n      id: TransportIdentifier;\n    });\n\nexport type ProgressEvent = Exclude<QueryEvent, { type: \"started\" }>;\n","import type { HookWrappers } from \"@apollo/client/react/internal\";\nimport { useTransportValue } from \"./useTransportValue.js\";\nimport { useWrapTransportedQueryRef } from \"../transportedQueryRef.js\";\nimport { useMemo } from \"react\";\n\nexport const hookWrappers: HookWrappers = {\n  useFragment(orig_useFragment) {\n    return wrap(orig_useFragment, [\"data\", \"complete\", \"missing\"]);\n  },\n  useQuery(orig_useQuery) {\n    return wrap<typeof orig_useQuery>(\n      process.env.REACT_ENV === \"ssr\"\n        ? (query, options) =>\n            orig_useQuery(query, { ...options, fetchPolicy: \"cache-only\" })\n        : orig_useQuery,\n      [\"data\", \"loading\", \"networkStatus\"]\n    );\n  },\n  useSuspenseQuery(orig_useSuspenseQuery) {\n    return wrap(orig_useSuspenseQuery, [\"data\", \"networkStatus\"]);\n  },\n  useReadQuery(orig_useReadQuery) {\n    return wrap(\n      (queryRef) => {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        return orig_useReadQuery(useWrapTransportedQueryRef(queryRef));\n      },\n      [\"data\", \"networkStatus\"]\n    );\n  },\n  useQueryRefHandlers(orig_useQueryRefHandlers) {\n    return wrap((queryRef) => {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      return orig_useQueryRefHandlers(useWrapTransportedQueryRef(queryRef));\n    }, []);\n  },\n  useSuspenseFragment(orig_useSuspenseFragment) {\n    return wrap(orig_useSuspenseFragment, [\"data\"]);\n  },\n};\n\nfunction wrap<T extends (...args: any[]) => any>(\n  useFn: T,\n  transportKeys: (keyof ReturnType<T>)[]\n): T {\n  return ((...args: any[]) => {\n    const result = useFn(...args);\n    if (transportKeys.length == 0) {\n      return result;\n    }\n    const forTransport = useMemo<Partial<typeof result>>(() => {\n      const transport: Partial<typeof result> = {};\n      for (const key of transportKeys) {\n        transport[key] = result[key];\n      }\n      return transport;\n    }, [result]);\n    const transported = useTransportValue(forTransport);\n\n    return useMemo(\n      () => ({ ...result, ...transported }),\n      [result, transported]\n    );\n  }) as T;\n}\n","import { gql } from \"@apollo/client\";\nimport type { DocumentNode, FetchPolicy, ApolloClient } from \"@apollo/client\";\nimport { print } from \"@apollo/client/utilities\";\nimport { stripIgnoredCharacters } from \"graphql\";\n\nexport type TransportedOptions = { query: string } & Omit<\n  ApolloClient.WatchQueryOptions,\n  \"query\"\n>;\n\nexport function serializeOptions<\n  T extends ApolloClient.WatchQueryOptions<any, any>,\n>(\n  options: T\n): { query: string; nextFetchPolicy?: FetchPolicy | undefined } & Omit<\n  T,\n  \"query\"\n> {\n  return {\n    ...(options as typeof options & {\n      // little bit of a hack around the method signature, but the method signature would cause React to error anyways\n      nextFetchPolicy?: FetchPolicy | undefined;\n    }),\n    query: printMinified(options.query),\n  };\n}\n\nexport function deserializeOptions(\n  options: TransportedOptions\n): ApolloClient.WatchQueryOptions {\n  return {\n    ...options,\n    // `gql` memoizes results, but based on the input string.\n    // We parse-stringify-parse here to ensure that our minified query\n    // has the best chance of being the referential same query as the one used in\n    // client-side code.\n    query: gql(print(gql(options.query))),\n  };\n}\n\nfunction printMinified(query: DocumentNode): string {\n  return stripIgnoredCharacters(print(query));\n}\n","import type { bundle } from \"./bundleInfo.js\";\nimport { sourceSymbol } from \"./bundleInfo.js\";\n\nexport function assertInstance(\n  value: { [sourceSymbol]?: string },\n  info: typeof bundle,\n  name: string\n): void {\n  if (value[sourceSymbol] !== `${info.pkg}:${name}`) {\n    throw new Error(\n      `When using \\`${name}\\` in streaming SSR, you must use the \\`${name}\\` export provided by \\`\"${info.pkg}\"\\`.`\n    );\n  }\n}\n","\"use client\";\nimport React from \"react\";\nimport { useRef } from \"react\";\nimport type { ApolloClient } from \"./WrappedApolloClient.js\";\nimport { ApolloProvider } from \"@apollo/client/react\";\nimport type { DataTransportProviderImplementation } from \"./DataTransportAbstraction.js\";\nimport { ApolloClientSingleton } from \"./symbols.js\";\nimport { bundle } from \"../bundleInfo.js\";\nimport { assertInstance } from \"../assertInstance.js\";\n\ndeclare global {\n  interface Window {\n    [ApolloClientSingleton]?: ApolloClient;\n  }\n}\n\n/**\n * > This is only available in React Client Components\n *\n * A version of `ApolloProvider` particularly suited for React's streaming SSR.\n *\n * @public\n */\nexport interface WrappedApolloProvider<ExtraProps> {\n  ({\n    makeClient,\n    children,\n    ...extraProps\n  }: React.PropsWithChildren<\n    {\n      makeClient: () => ApolloClient;\n    } & ExtraProps\n  >): React.JSX.Element;\n  /**\n   * Information about the current package and it's export names, for use in error messages.\n   */\n  info: {\n    pkg: string;\n  };\n}\n\n/**\n * > This export is only available in React Client Components\n *\n * Creates an ApolloProvider for streaming SSR.\n *\n * @param TransportProvider - The transport provider to be used.\n * This could e.g. be a `ManualDataTransport` created by `buildManualDataTransport`,\n * or a fully custom implementation of `DataTransportProviderImplementation`.\n * @public\n */\nexport function WrapApolloProvider<ExtraProps>(\n  TransportProvider: DataTransportProviderImplementation<ExtraProps>\n): WrappedApolloProvider<ExtraProps> {\n  const WrappedApolloProvider: WrappedApolloProvider<ExtraProps> = ({\n    makeClient,\n    children,\n    ...extraProps\n  }) => {\n    const clientRef = useRef<ApolloClient>(undefined);\n    if (!clientRef.current) {\n      if (process.env.REACT_ENV === \"ssr\") {\n        clientRef.current = makeClient();\n      } else {\n        clientRef.current = window[ApolloClientSingleton] ??= makeClient();\n      }\n      assertInstance(\n        clientRef.current,\n        WrappedApolloProvider.info,\n        \"ApolloClient\"\n      );\n    }\n\n    return (\n      <ApolloProvider client={clientRef.current}>\n        <TransportProvider\n          onQueryEvent={(event) =>\n            event.type === \"started\"\n              ? clientRef.current!.onQueryStarted!(event)\n              : clientRef.current!.onQueryProgress!(event)\n          }\n          rerunSimulatedQueries={clientRef.current.rerunSimulatedQueries}\n          registerDispatchRequestStarted={\n            clientRef.current.watchQueryQueue?.register\n          }\n          {...(extraProps as ExtraProps)}\n        >\n          {children}\n        </TransportProvider>\n      </ApolloProvider>\n    );\n  };\n  WrappedApolloProvider.info = bundle;\n  return WrappedApolloProvider;\n}\n"],"names":["useApolloClient","useMemo","reader","ApolloLink","Observable","ApolloLink","useApolloClient","useMemo"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11],"debugId":null}}]
}